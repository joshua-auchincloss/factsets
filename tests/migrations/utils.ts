import { unlink, access, stat, readFile } from "node:fs/promises";
import { join } from "node:path";
import packageJson from "../../package.json" with { type: "json" };

export const IS_WINDOWS = process.platform === "win32";

/**
 * Sleep for a given number of milliseconds
 */
export function sleep(ms: number): Promise<void> {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Try to delete a file with retries for Windows file locking issues.
 * Throws if the file cannot be deleted after all retries.
 */
export async function unlinkWithRetry(
	filePath: string,
	maxRetries = 5,
	delayMs = 200,
): Promise<void> {
	let lastError: Error | null = null;

	for (let i = 0; i < maxRetries; i++) {
		try {
			await access(filePath);
			await unlink(filePath);
			return; // Success
		} catch (error: unknown) {
			const err = error as NodeJS.ErrnoException;
			if (err.code === "ENOENT") {
				return; // File doesn't exist, success
			}
			lastError = err;
			if (
				err.code === "EBUSY" ||
				err.code === "EPERM" ||
				err.code === "EACCES"
			) {
				// File is locked, wait and retry
				if (i < maxRetries - 1) {
					await sleep(delayMs * (i + 1)); // Exponential backoff
					continue;
				}
			}
			// Non-retryable error, throw immediately
			throw new Error(
				`Failed to delete ${filePath}: ${err.code} - ${err.message}`,
			);
		}
	}

	// Max retries reached
	throw new Error(
		`Failed to delete ${filePath} after ${maxRetries} retries: ${lastError?.message ?? "unknown error"}`,
	);
}

export const CURRENT_VERSION = packageJson.version;

/** Minimum version to include in migration tests */
export const MIN_TEST_VERSION = "0.1.0";

export interface VersionInfo {
	version: string;
	tag: string;
	isPublished: boolean;
	isDevelopment: boolean;
}

/**
 * Versions manifest generated by pre-test script
 */
interface VersionsManifest {
	generatedAt: string;
	minVersion: string;
	versions: string[];
	tags: string[];
}

/** Path to versions.json generated by pre-test script */
const VERSIONS_FILE = join(import.meta.dir, "..", "..", "versions.json");

/** Cached versions from manifest */
let cachedManifest: VersionsManifest | null = null;

/**
 * Load versions manifest from versions.json (generated by pre-test script).
 * Throws if file doesn't exist or is invalid - ensures pre-test was run.
 */
async function loadVersionsManifest(): Promise<VersionsManifest> {
	if (cachedManifest) {
		return cachedManifest;
	}

	try {
		const content = await readFile(VERSIONS_FILE, "utf-8");
		cachedManifest = JSON.parse(content) as VersionsManifest;

		if (!cachedManifest.versions || !Array.isArray(cachedManifest.versions)) {
			throw new Error(
				"Invalid versions.json: missing or invalid 'versions' array",
			);
		}

		if (!cachedManifest.tags || !Array.isArray(cachedManifest.tags)) {
			throw new Error("Invalid versions.json: missing or invalid 'tags' array");
		}

		return cachedManifest;
	} catch (error) {
		if (error instanceof SyntaxError) {
			throw new Error(`Invalid JSON in versions.json: ${error.message}`);
		}
		const err = error as NodeJS.ErrnoException;
		if (err.code === "ENOENT") {
			throw new Error(
				"versions.json not found - run 'bun run pre-test' before running migration tests",
			);
		}
		throw error;
	}
}

/**
 * Get release tags from versions.json manifest.
 * Tags are pre-sorted in ascending order by the pre-test script.
 * Throws if versions.json is missing or invalid.
 */
export async function getReleaseTags(): Promise<string[]> {
	const manifest = await loadVersionsManifest();
	return manifest.tags;
}

/**
 * Get all published versions from versions.json manifest.
 * Versions are pre-sorted in ascending order by the pre-test script.
 * Throws if versions.json is missing or invalid.
 */
export async function getPublishedVersions(): Promise<string[]> {
	const manifest = await loadVersionsManifest();
	return manifest.versions;
}

/**
 * Convert version to tag format (e.g., "0.1.0" -> "v0.1.0")
 */
export function versionToTag(version: string): string {
	return version.startsWith("v") ? version : `v${version}`;
}

/**
 * Convert tag to version format (e.g., "v0.1.0" -> "0.1.0")
 */
export function tagToVersion(tag: string): string {
	return tag.replace(/^v/, "");
}

/**
 * Check if a version exists as a GitHub tag.
 * CI enforces that all tags have corresponding releases.
 */
export async function isVersionPublished(version: string): Promise<boolean> {
	const tags = await getReleaseTags();
	const tag = versionToTag(version);
	return tags.includes(tag);
}

/**
 * Get full version information including publication status
 */
export async function getVersionInfo(version: string): Promise<VersionInfo> {
	const normalizedVersion = version.replace(/^v/, "");
	return {
		version: normalizedVersion,
		tag: versionToTag(normalizedVersion),
		isPublished: await isVersionPublished(normalizedVersion),
		isDevelopment: normalizedVersion === CURRENT_VERSION,
	};
}

/**
 * Get all versions with their info.
 * Versions are pre-sorted in ascending order by the pre-test script.
 */
export async function getAllVersionsInfo(): Promise<VersionInfo[]> {
	const tags = await getReleaseTags();
	const versions = tags.map((tag) => tagToVersion(tag));

	// Add current version if not in tags (at end since it's always newest)
	if (!versions.includes(CURRENT_VERSION)) {
		versions.push(CURRENT_VERSION);
	}

	const infos: VersionInfo[] = [];

	for (const version of versions) {
		infos.push(await getVersionInfo(version));
	}

	return infos;
}

/**
 * Database file utilities for migration testing
 */
export class MigrationTestDb {
	constructor(public readonly path: string) {}

	/**
	 * Clean up the test database file and associated files.
	 * Uses retry logic on Windows to handle file locking issues.
	 */
	async cleanup(): Promise<void> {
		const files = [this.path, `${this.path}-wal`, `${this.path}-shm`];

		// On Windows, add initial delay to allow process cleanup
		if (IS_WINDOWS) {
			await sleep(500);
		}

		for (const file of files) {
			if (IS_WINDOWS) {
				// Use retry logic on Windows due to file locking
				await unlinkWithRetry(file, 10, 300);
			} else {
				try {
					await access(file);
					await unlink(file);
				} catch {
					// File doesn't exist
				}
			}
		}
	}

	/**
	 * Check if the database exists and has data
	 */
	async exists(): Promise<boolean> {
		try {
			const stats = await stat(this.path);
			return stats.size > 0;
		} catch {
			return false;
		}
	}

	/**
	 * Get the database connection URL for use with factsets
	 */
	get connectionUrl(): string {
		return `sqlite://${this.path}`;
	}
}

/**
 * Create command args for running a specific version of factsets
 */
export function createVersionArgs(
	version: string,
	dbPath: string,
	options: { watchSkills?: boolean } = {},
): { command: string; args: string[] } {
	const normalizedVersion = version.replace(/^v/, "");
	const isDevelopment = normalizedVersion === CURRENT_VERSION;

	const baseArgs = ["mcp-server", "--database-url", `sqlite://${dbPath}`];

	if (!options.watchSkills) {
		baseArgs.push("--no-watch-skills");
	}

	if (isDevelopment) {
		return {
			command: "./node_modules/.bin/bun",
			args: ["src/main.ts", ...baseArgs],
		};
	}

	return {
		command: "./node_modules/.bin/bunx",
		args: [`factsets@${normalizedVersion}`, ...baseArgs],
	};
}
